package main

import (
	"flag"
	"fmt"
	"log"
	"os"
	"strings"
	"text/template"
)

const (
	codeTemplate = `// Code generated by {{.Command}}; DO NOT EDIT.
package {{.Package}}

func init() {
	Pool = []string{
		{{range .Items}}"{{.Key}}",
		{{end}}
	}
        words = map[string]bool{
                {{range .Items}}"{{.Key}}": {{.Value}},
                {{end}}
        }
}`
)

type Config struct {
	Command string
	Package string
	Items   []Element
}

type Element struct {
	Key   string
	Value string
}

func main() {
	length := flag.Int("l", 5, "")
	output := flag.String("o", "dictionary.pb.go", "output filepath")
	flag.Parse()
	fmt.Println("Start generating")

	// load and parse template
	raw := template.New("generator")
	tmpl, err := raw.Parse(codeTemplate)
	panicOn(err)

	// prepare output writer
	f, err := os.Create(*output)
	panicOn(err)
	defer f.Close()

	// create output
	elements := buildElements(*length)
	command := "go run generator.go"
	if len(os.Args) > 1 {
		command = fmt.Sprintf("go run generator.go %s", strings.Join(os.Args[1:], " "))
	}
	tmpl.Execute(f, Config{Command: command, Package: "dictionary", Items: elements})
}

func buildElements(l int) []Element {
	data, err := os.ReadFile("/usr/share/dict/words")
	panicOn(err)
	words := strings.Split(string(data), "\n")
	result := make([]Element, 0)
	pool := make(map[string]bool)
	for _, raw := range words {
		word := strings.ToLower(raw)
		if len(word) == l && !pool[word] {
			result = append(result, Element{Key: word, Value: "true"})
			pool[word] = true
		}
	}
	return result
}

func panicOn(err error, msg ...string) {
	if err != nil {
		log.Println(msg)
		panic(err)
	}
}
